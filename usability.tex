\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TFPIE 2016} % Name of the event you are submitting to
\usepackage{url}
\usepackage{color}

\newcommand{\allcomments}[1]{{#1}}
%\newcommand{\allcomments}[1]{}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
\definecolor{Teal}{RGB}{2,132,130}
% Uncomment this if you don't want to show comments
\newcommand{\emcomment}[1]{{\bf \textcolor{ForestGreen}{\allcomments{{#1}}}}}
\newcommand{\hfcomment}[1]{\textcolor{Teal}{\allcomments{Henry: {#1}}}}
\newcommand{\thcomment}[1]{{\bf \textcolor{blue}{\allcomments{{#1}}}}}
\newcommand{\todo}[1]{{\bf \color{magenta}{\allcomments{ To-do: {#1}}}}}


\title{TBD: Usability of Clojure error messages (extended abstract).}
\author{Elena Machkasova 
\institute{University of Minnesota, Morris
\email{elenam@morris.umn.edu}}
\and
Henry Fellows
\institute{University of Minnesota, Morris
\email{?@morris.umn.edu}}
\and 
Thomas Hagen
\institute{University of Minnesota, Morris
\email{hagen715@morris.umn.edu}}
\and Sean Stockholm
\institute{University of Minnesota, Morris
\email{?@morris.umn.edu}}
}
\def\titlerunning{Clojure error messages}
\def\authorrunning{E. Machkasova, H. Fellows, T. Hagen \& S. Stockholm }
\begin{document}
\maketitle

\begin{abstract}
TBD
\end{abstract}

\section{Introduction}\label{sec:intro}
Error messages are the primary form of response that programmers get from malfunctioning programs. 
Experienced programmers have the background to understand what error messages actually mean, but novices only have the content of the error message. 
While interactions with errors in a programming language are an essential part of a programmer's experience, quite often error handling in a language is not very well thought through: 
error messages use inconsistent terminology, are ambiguous or misleading, and do not provide enough detail. 
%Beginner programmers find error messages unhelpful.
%Anecdotal evidence (informal questioning of about 10 CS students and almuni by the authors) indicates that novice programmers often do not even realize that an error message may contain useful information, except perhaps the line number; some ignore these messages entirely. 
%This observation is consistent with the general programming languages community undervaluing of error messages quality. 
There has been very little formal study of usability of error messages for beginners, and very little methodology developed for such studies. The notable exception is the development and study of beginner-friendly error messages in the Racket programming language \cite{Marceau:2011,Marceau:2011-2}. 

\section{Towards teaching Clojure in an introductory class}\label{sec:project}
\emcomment{Some of this may move to intro}
Languages in the Lisp family have a long history of being a successful first programming language for college-level students.
The famous Abelson and Sussman textbook~\cite{Abelson} had been used in numerous introductory courses.
In the recent years Python replaced Lisp/Scheme as a first beginners' language to a large degree. However, 
Felleisen et al made an excellent case for using a functional language as a first language in  CS education~\cite{Felleisen:2004}.   
Functional languages tend to have simpler, more uniform syntax and semantics that students master quickly.
They focus on functional abstraction, modularity, generalization, and recursion -- concepts that are essential for computer science methods of 
problem solving and a structural, systematic approach to software development. 
Lisp Read-Eval-Print Loop (REPL) provides an opportunity to test code interactively as it is being developed. 
Lisps have been successfully used in introductory languages in many computer science college programs, including UMM: 
one of our introductory classes for CS majors and minors uses Racket programming language~\cite{htdp,htdp2}. 
%(the other,
%equivalent, one uses Python). 

Clojure is a relatively new addition to the Lisp language family. Released in 2007 by Rich Hickey~\cite{Hickey:2008}, it has rapidly gained popularity in industry
and in a wider programming community 
due to its elegant design and suitability for concurrent programming. A very active open source Clojure community has developed numerous 
libraries for a diverse set of applications, from web development to data processing. 

Our project aims at creating a setup for using Clojure in an introductory CS class. Clojure was designed with experienced programmers in mind, 
and using it as a first programming language presents challenges. Our goal is to develop ways to support beginner-friendly Clojure interactions. 

\subsection{Overview of Clojure}\label{subsec:clojure}

\emcomment{Features: JVM, data structures, dynamic types -- not in this order, probably}
Unlike other Lisps that come with their own interpreter that was developed just for their own dialect, Clojure is compiled 
into Java bytecode and runs on the Java virtual machine (JVM). This provides the benefits of compatibility with 
any platform that supports Java, the ability to use any Java library, and the opportunity to take advantage of Java 
garbage collection and runtime optimizations. However, this also presents a challenge since the underlying Java 
runtime environment operates with Java types, and Clojure error messages come directly from the Java runtime
system. We discuss implications of this design decision in Section~\ref{subsec:challenges}.

Like all Lisp, Clojure is dynamically typed. This has an advantage that beginners do not need to worry about type declarations
for variables and functions, and it is easy to write polymorphic functions. 
Data is immutable by default: there are several built-in data types that support various concurrency models, 
but it is easy to present a completely immutable subset of the language to beginners. 
The language provides a rich system of predefined collection: lists, vectors, hash maps, and set, to name the 
most common ones. Many functions that work on collections return lazy sequences: sequences that are not evaluated 
until they are needed, and only the needed portion is evaluated. 

\subsection{Challenges}\label{subsec:challenges}
One of the main challenges in using Clojure as a language for beginner programmers is its error messages. 
Since Clojure is a dynamically typed language that runs on the JVM, most of its errors
are runtime and manifest themselves as Java exception.
For instance, an attempt to apply {tt first} to a number, such as {(first 3)}, 
would result in a type mismatch between the expected type (a sequence or a type that can be converted to a sequence) 
and the actual type, which is a number. A general Clojure sequence type  is represented in Java as 
{\tt ISeq}, and integer numbers are, by default, stored as the (boxed) type {\tt Long}. Thus the error message becomes
\begin{verbatim}
Exception in thread "main" java.lang.IllegalArgumentException:
Don't know how to create ISeq from: java.lang.Long
\end{verbatim}
Beginners do not know what {\tt IllegalArgumentException} or the other two types mentioned in the message are, and have no
way of matching them to the context of their program. 

To make the matters worse, the error comes with a very long (several dozens of lines) Java stack trace, primarily consisting of internal 
representation of Clojure functions and setup, not any of the code that the programmer actually wrote. 



\emcomment{mention IDE, in addition to the error messages}

\emcomment{multiple types for the same thing; a bit of type confusion due to the same elements implementing different interfaces}

\section{Error messages adapted for beginners}\label{sec:errors-work}
\hfcomment{WORRRRRRRRRRRRRRRRRRRDS}

\subsection{Examples}
Here are some examples of the error messages we've developed, and the original error messages. 
The examples of original error messages have been limited in length; they always include a complete stack trace that is no shorter than fifty lines.

\subsubsection{Illegal argument}
{\tt (first 3)}

Here we attempt to take the first of a number:
\begin{verbatim}
Exception in thread "main" java.lang.IllegalArgumentException:
Don't know how to create ISeq from:
java.lang.Long, compiling:(/tmp/form-init143909617110072064.clj:1:72)
\end{verbatim}


And our improved version of the error:
\begin{verbatim}
In function first, the first argument 3 must be a sequence but is a number.
\end{verbatim}

\subsubsection{Incorrect arity}
{\tt (even? 3 6 1)}

This example demonstrates arity exceptions on \texttt{even?}:
\begin{verbatim}
Exception in thread "main" clojure.lang.ArityException:
Wrong number of args (3) passed to:
core/even?, compiling:(/tmp/form-init5079227190989845185.clj:1:73)
\end{verbatim}
And our improved version of the error:
\begin{verbatim}
You cannot pass three arguments to a function even?, need one.
\end{verbatim}

\subsubsection{Incorrect arity of a lambda}
{\tt ((fn [ x y] (+ x y)) 2)}

An anonymous function that takes two args and is given one:
\begin{verbatim}
Exception in thread "main" clojure.lang.ArityException:
Wrong number of args (1) passed to: 
core/-main/fn--1012, compiling:(/tmp/form-init5193142143408385708.clj:1:73)
\end{verbatim}
And our improved version of the error:
\begin{verbatim}
You cannot pass one argument to this anonymous function.
\end{verbatim}

\subsubsection{Calling nil as a function}
{\tt (nil 5)}

The result of calling nil as a function:
\begin{verbatim}
Exception in thread "main" java.lang.IllegalArgumentException:
Can't call nil, compiling:
(amicable/core.clj:29:1)
\end{verbatim}
And our improved version of the error:
\begin{verbatim}
Cannot call nil as a function.
\end{verbatim}

\subsection{Stack filtering}
We also filter the stack trace, removing portions that mention the compiler and internals of Clojure. For example, the stracktrace 

\emcomment{Might need to shorten, move}

\begin{verbatim}
corefns.corefns/first (corefns.clj line 38)
intro.may2015/eval8701 (may2015.clj line 48)
clojure.lang.Compiler/eval (Compiler.java line 6792)
clojure.lang.Compiler/load (Compiler.java line 7237)
clojure.lang.Compiler/loadFile (Compiler.java line 7175)
clojure.lang.RT$3/invoke (RT.java line 319)
intro.core/-main (core.clj line 114)
clojure.lang.RestFn/invoke (RestFn.java line 397)
clojure.lang.Var/invoke (Var.java line 375)
user/eval5 (form-init4829442094537982229.clj line 1)
clojure.lang.Compiler/eval (Compiler.java line 6792)
clojure.lang.Compiler/eval (Compiler.java line 6782)
clojure.lang.Compiler/load (Compiler.java line 7237)
clojure.lang.Compiler/loadFile (Compiler.java line 7175)
clojure.main/load-script (main.clj line 275)
clojure.main/init-opt (main.clj line 280)
clojure.main/initialize (main.clj line 308)
clojure.main/null-opt (main.clj line 343)
clojure.main/main (main.clj line 421)
\end{verbatim}
 
becomes 

\begin{verbatim}
corefns.corefns/first (corefns.clj line 38)
intro.may2015/eval8701 (may2015.clj line 48)
intro.core/-main (core.clj line 114)
\end{verbatim} 
 
Which should be considerably better.
\hfcomment{actually words here}
\emcomment{Stack filtering}

\emcomment{Lazy sequences preview}

\section{Design of usability study}\label{sec:study}
	\thcomment{This is just the MICS section copied over}
	
	\subsection{Study participants}\label{sec:obj}
The usability study that we have developed is structured around ``parallel questions'': erroneous fragments that are the same in 
Racket and Clojure (except the syntactic differences), but result in different error messages.  
The participants for the study are volunteer students from the U of M, Morris who have taken the introductory computer science course in Racket and have no, or very little, experience with Clojure.
Participants will be recruited via the CS department mailing list, as well as via email and short presentations in freshmen and sophomore level CS classes. 
In order to attract a larger and more diverse student population for the study, students will be compensated for their time, thanks to a gift from Cognitect, Inc. 
The study is exempt from full IRB review. 

	\subsection{Experimental Setup}\label{sec:setup}
	
%\thcomment{I did not put the following line here, is someone missing this?}
%properly because of the limitations of the Java virtual machine.
	   


\subsubsection{Languages overview}\label{subsec:overview}

The study is split into two main parts: Racket review and testing, and a brief overview of Clojure and testing.
The goal of each section is to introduce the two languages' basic functionality and then test the participants ability to correct mistakes in that language.
Testing is followed by a brief ``interview'' at the end. 
The overall purpose of each instructional session is to ensure that the participants have enough fundamental knowledge of the language presented to them to have a basic understanding of the problems. 
In addition, the session should also ensure a relatively similar level of familiarity with both Clojure and Racket among all participants. 
Each participant in the study will go through the process of reviewing and testing individually in order to minimize outside influence from other participants or distractions. 
Because of this, the participant's experiences must be parallel with each other both in terms of the environment and the materials provided such as not to create bias.

The Racket review section will be a reintroduction to participants, as they should already have a base knowledge of Racket from previous courses taken.
The participants should have little or no knowledge of Clojure when coming into the study, so the Clojure lesson will focus more on drawing similarities from Racket and basic function explanations.
The core topics to cover for each language are syntax (such as the prefix notation), higher order functions, function definitions, and recursion.
This part will consist of a brief writeup with examples. The Clojure writeup will assume familiarity with Racket and will highlight the differences. 

\subsubsection{Testing}\label{subsec:testing}

After the overview the participants will be assigned to a computer where their actions will be monitored by a reviewer. 
From here, they will be directed to connect to a website we have constructed that will present them with a series of problems to solve. 
Participants will not be allowed to consult outside sources, the reviewer, or other participants during this period of the study except for the language's public API for Racket and Clojuredocs for Clojure.
The participants will also have access to Racket's built-in IDE for Racket questions and to a project in the LightTable code editor for the Clojure questions. 

The website they connect to pulls its questions from a set of parallel questions between Clojure and Racket we have constructed, so that for every question in Racket there is an equivalent question in Clojure and vice-versa.
Each question pair has a difficulty rating associated with it, with 1 being the easiest questions and 5 being the hardest.
When a new participant logs into the website, it constructs both the Racket and Clojure tests to present by randomly selecting question-pairs from the pool and adding the version of that question that corresponds to the language the test is in. 
The program iterates over every question in the pool and adds approximately equivalent amounts of questions from each level of difficulty level to each of the two tests.
	The participants will be allocated a time limit of 20 minutes to answer the questions in each language. 
They are allowed to try as many times as needed on each questions and they are allowed to skip past questions with the possibility of coming back to them later on. 

Before taking their Clojure test each participant will  be assigned to receive either Clojure's default error messages or our custom Clojure error messages.
While testing, the computer will take a screenshot periodically, and the reviewer will take notes on what the participant does while solving the problems.
Screenshots in which there are no changes in screen state will be discarded. 
Each session will result in a series of screenshots and a short ``script'' of the participant's actions with timestamps in minutes and seconds since the beginning of the test, e.g. ``At 1:12 ran the program, got a message \texttt{Cannot convert 2 to a function}, at 1:45 switched the order of the function parameters'', etc.
After the finishing all of the questions, the participant will be asked a series of questions related to the tests such as, "What part of the tasks were easy for you? What parts were hard?".
Understanding each participants problem solving process will be based in both the notes and screenshots taken.

\subsubsection{Data evaluation}\label{subsec:evaluation}

After the question period of the study, we will now have a collection of screen captures from each participant detailing the process solving the problems, notes on their problem solving process, and participant opinion on the challenges of the study.
From these we can begin to gauge the significance of the error messages in their problem solving processes. 
Numerical data (the number and the level of the solved problems, total time until correct solutions, the number of edits towards the right solution vs those leading away) will be processed statistically. 

The questions at the end would allow us to gauge how the messages are perceived, and whether this correlates with their actual usefulness. A positive correlation would be useful to know for future research, allowing us to rely on participants' feedback. 
Lack of such correlation would mean that participants' perception is unreliable and should not be used for future evaluation.  

\section{Principles of Question Selection}\label{sec:select}
	Selecting questions for the study was a challenging process since every question must make sense in both Racket and Clojure and not require an involved introduction. Below we detail our approach to question selection.

	\subsection{Selecting Meaningful Accessible Questions}\label{sec:meaning}
	When putting together questions for the study, we followed the following principles:
	\begin{itemize}
	\item The code examples should be simple enough to understand the programmer's intent with just a few test examples. 
	\item The code examples must have mistakes that a beginner programmer would make. Examples include switched arguments of a function or a mistyped identifier. 
	\item There must be a simple fix for an error. This is challenging since some errors, such as s type mismatch, can be caused by a variety of issues, and a beginner
	programmer can easily start making changes that are more complicated than they need to be, in an attempt to match the types. 
	\item Code examples and tests must use the same simple set of features in Racket and in Clojure. For instance, Racket uses a function \texttt{check-expect} for testing. Clojure also has a similar library (expectations), but it is more convoluted. Thus in order to equalize the experience in the two languages we chose to use only = and \texttt{equals?} function for testing since they are the same in the two languages. 
	\end{itemize}


	\subsection{Question Parallelism}\label{sec:parallel}
	
	One of the overarching themes of this study was the difficulty in creating questions that had similar meaning, errors, and syntax in both Clojure and Racket. 
	Often, our questions are somewhat less than idiomatic because of the constraints imposed by the short time commitment we intended for the study.
	For instance, we only use lists in our questions, where idiomatic Clojure prefers vectors, which combine the best features of arrays and lists.
	 Reducing the amount of review and potential sources of confusion was paramount; For instance, Clojure doesn't support tail recursion properly because of the limitations of the Java virtual machine.
	 In order to create tail-recursive structures, idiomatic Clojure uses a construct called loop recur to bypass this limitation.
	 Loop recur has complex syntax and semantics, and so our questions avoid the use of Loop recur, despite the fact that it is idiomatic. 
	 The gap between idiomatic code and testable code is wide, but avoiding complex features is a good start. %\hfcomment{Cond?}

\subsection{Conclusions and future work}\label{sec:future}

\bibliographystyle{eptcs}
\bibliography{usability}
\end{document}



