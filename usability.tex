\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TFPIE 2016} % Name of the event you are submitting to
\usepackage{url}
\usepackage{color}

\newcommand{\allcomments}[1]{{#1}}
%\newcommand{\allcomments}[1]{}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
% Uncomment this if you don't want to show comments
\newcommand{\emcomment}[1]{{\bf \textcolor{ForestGreen}{\allcomments{{#1}}}}}
\newcommand{\thcomment}[1]{{\bf \textcolor{blue}{\allcomments{{#1}}}}}
\newcommand{\todo}[1]{{\bf \color{magenta}{\allcomments{ To-do: {#1}}}}}


\title{TBD: Usability of Clojure error messages (extended abstract).}
\author{Elena Machkasova 
\institute{University of Minnesota, Morris
\email{elenam@morris.umn.edu}}
\and
Henry Fellows
\institute{University of Minnesota, Morris
\email{?@morris.umn.edu}}
\and 
Thomas Hagen
\institute{University of Minnesota, Morris
\email{hagen715@morris.umn.edu}}
\and Sean Stockholm
\institute{University of Minnesota, Morris
\email{?@morris.umn.edu}}
}
\def\titlerunning{Clojure error messages}
\def\authorrunning{E. Machkasova, H. Fellows, T. Hagen \& S. Stockholm }
\begin{document}
\maketitle

\begin{abstract}
TBD
\end{abstract}

\section{Introduction}\label{sec:intro}

\section{Towards teaching Clojure in an introductory class}\label{sec:project}
\emcomment{Some of this may move to intro}
Languages in the Lisp family have along history of being a successful first programming language for college-level students~\cite{Felleisen:2004}. 
Functional languages tend to have simpler, more uniform syntax and semantics that students master quickly.
They focus on functional abstraction, modularity, generalization, and recursion -- concepts that are essential for computer science methods of 
problem solving and a structural, systematic approach to software development. 
Lisp Read-Eval-Print Loop (REPL) provides an opportunity to test code interactively as it's being developed. 
Lisps have been successfully used in introductory languages in many computer science college programs, including UMM: 
one of our introductory classes for CS majors and minors uses Racket programming language~\cite{htdp,htdp2} (the other,
equivalent, one uses Python). 

Clojure is a relatively new addition to the Lisp language family. Released in 2007 by Rich Hickey~\cite{Hickey:2008}, it has rapidly gained popularity in industry
and in programming community in general 
due to its elegant design and suitability for concurrent programming. A very active open source Clojure community has developed numerous 
libraries for a diverse set of applications, from web development to data processing. 

Our project aims at creating a setup for using Clojure in an introductory CS class. Clojure was designed with experienced programmers in mind, 
and using it as a first programming language presents challenges. Our goal is to develop ways to support beginner-friendly Clojure interactions. 

\subsection{Overview of Clojure}\label{subsec:clojure}

\emcomment{Features: JVM, data structures, dynamic types -- not in this order, probably}
Unlike other Lisps that come with their own interpreter that was developed just for their own dialect, Clojure is compiled 
into Java bytecode and runs on the Java virtual machine (JVM). This provides the benefits of compatibility with 
any platform that supports Java, the ability to use any Java library, and the opportunity to take advantage of Java 
garbage collection and runtime optimizations. However, this also presents a challenge since the underlying Java 
runtime environment operates with Java types, and Clojure error messages come directly from the Java runtime
system. We discuss implications of this design decision in Section~\ref{subsec:challenges}.

\subsection{Challenges}\label{subsec:challenges}

\emcomment{mention IDE, in addition to the error messages}

\section{Error messages adapted for beginners}\label{sec:errors-work}
%\emcomment{Make sure that examples are more involved than in the previous paper}

{\tt (first 3)}

\begin{verbatim}
In function first, the first argument 3 must be a sequence but is a number.
\end{verbatim}

\emcomment{Show original}

{\tt (even? 3 6 1)}

\begin{verbatim}
You cannot pass three arguments to a function even?, need one.
\end{verbatim}

{\tt ((fn [ x y] (+ x y)) 2)}

\begin{verbatim}
You cannot pass one argument to this anonymous function.
\end{verbatim}

\begin{verbatim}
Cannot call nil as a function.
\end{verbatim}

{\tt (nil 5)}

\emcomment{Stack filtering}

\section{Design of usability study}\label{sec:study}
	\thcomment{This is just the MICS section copied over}
	
	\subsection{Study participants}\label{sec:obj}
The usability study that we have developed is structured around ``parallel questions'': erroneous fragments that are the same in 
Racket and Clojure (except the syntactic differences), but result in different error messages.  
The participants for the study are volunteer students from the U of M, Morris who have taken the introductory computer science course in Racket and have no, or very little, experience with Clojure.
Participants will be recruited via the CS department mailing list, as well as via email and short presentations in freshmen and sophomore level CS classes. 
In order to attract a larger and more diverse student population for the study, students will be compensated for their time, thanks to a gift from Cognitect, Inc. 
The study is exempt from full IRB review. 

	\subsection{Experimental Setup}\label{sec:setup}
	
%\thcomment{I did not put the following line here, is someone missing this?}
%properly because of the limitations of the Java virtual machine.
	   


\subsubsection{Languages overview}\label{subsec:overview}

The study is split into two main parts: Racket review and testing, and a brief overview of Clojure and testing.
The goal of each section is to introduce the two languages' basic functionality and then test the participants ability to correct mistakes in that language.
Testing is followed by a brief ``interview'' at the end. 
The overall purpose of each instructional session is to ensure that the participants have enough fundamental knowledge of the language presented to them to have a basic understanding of the problems. 
In addition, the session should also ensure a relatively similar level of familiarity with both Clojure and Racket among all participants. 
Each participant in the study will go through the process of reviewing and testing individually in order to minimize outside influence from other participants or distractions. 
Because of this, the participant's experiences must be parallel with each other both in terms of the environment and the materials provided such as not to create bias.

The Racket review section will be a reintroduction to participants, as they should already have a base knowledge of Racket from previous courses taken.
The participants should have little or no knowledge of Clojure when coming into the study, so the Clojure lesson will focus more on drawing similarities from Racket and basic function explanations.
The core topics to cover for each language are syntax (such as the prefix notation), higher order functions, function definitions, and recursion.
This part will consist of a brief writeup with examples. The Clojure writeup will assume familiarity with Racket and will highlight the differences. 

\subsubsection{Testing}\label{subsec:testing}

After the overview the participants will be assigned to a computer where their actions will be monitored by a reviewer. 
From here, they will be directed to connect to a website we have constructed that will present them with a series of problems to solve. 
Participants will not be allowed to consult outside sources, the reviewer, or other participants during this period of the study except for the language's public API for Racket and Clojuredocs for Clojure.
The participants will also have access to Racket's built-in IDE for Racket questions and to a project in the LightTable code editor for the Clojure questions. 

The website they connect to pulls its questions from a set of parallel questions between Clojure and Racket we have constructed, so that for every question in Racket there is an equivalent question in Clojure and vice-versa.
Each question pair has a difficulty rating associated with it, with 1 being the easiest questions and 5 being the hardest.
When a new participant logs into the website, it constructs both the Racket and Clojure tests to present by randomly selecting question-pairs from the pool and adding the version of that question that corresponds to the language the test is in. 
The program iterates over every question in the pool and adds approximately equivalent amounts of questions from each level of difficulty level to each of the two tests.
	The participants will be allocated a time limit of 20 minutes to answer the questions in each language. 
They are allowed to try as many times as needed on each questions and they are allowed to skip past questions with the possibility of coming back to them later on. 

Before taking their Clojure test each participant will  be assigned to receive either Clojure's default error messages or our custom Clojure error messages.
While testing, the computer will take a screenshot periodically, and the reviewer will take notes on what the participant does while solving the problems.
Screenshots in which there are no changes in screen state will be discarded. 
Each session will result in a series of screenshots and a short ``script'' of the participant's actions with timestamps in minutes and seconds since the beginning of the test, e.g. ``At 1:12 ran the program, got a message \texttt{Cannot convert 2 to a function}, at 1:45 switched the order of the function parameters'', etc.
After the finishing all of the questions, the participant will be asked a series of questions related to the tests such as, "What part of the tasks were easy for you? What parts were hard?".
Understanding each participants problem solving process will be based in both the notes and screenshots taken.

\subsubsection{Data evaluation}\label{subsec:evaluation}

After the question period of the study, we will now have a collection of screen captures from each participant detailing the process solving the problems, notes on their problem solving process, and participant opinion on the challenges of the study.
From these we can begin to gauge the significance of the error messages in their problem solving processes. 
Numerical data (the number and the level of the solved problems, total time until correct solutions, the number of edits towards the right solution vs those leading away) will be processed statistically. 

The questions at the end would allow us to gauge how the messages are perceived, and whether this correlates with their actual usefulness. A positive correlation would be useful to know for future research, allowing us to rely on participants' feedback. 
Lack of such correlation would mean that participants' perception is unreliable and should not be used for future evaluation.  

\section{Principles of Question Selection}\label{sec:select}
	Selecting questions for the study was a challenging process since every question must make sense in both Racket and Clojure and not require an involved introduction. Below we detail our approach to question selection.

	\subsection{Selecting Meaningful Accessible Questions}\label{sec:meaning}
	When putting together questions for the study, we followed the following principles:
	\begin{itemize}
	\item The code examples should be simple enough to understand the programmer's intent with just a few test examples. 
	\item The code examples must have mistakes that a beginner programmer would make. Examples include switched arguments of a function or a mistyped identifier. 
	\item There must be a simple fix for an error. This is challenging since some errors, such as s type mismatch, can be caused by a variety of issues, and a beginner
	programmer can easily start making changes that are more complicated than they need to be, in an attempt to match the types. 
	\item Code examples and tests must use the same simple set of features in Racket and in Clojure. For instance, Racket uses a function \texttt{check-expect} for testing. Clojure also has a similar library (expectations), but it is more convoluted. Thus in order to equalize the experience in the two languages we chose to use only = and \texttt{equals?} function for testing since they are the same in the two languages. 
	\end{itemize}


	\subsection{Question Parallelism}\label{sec:parallel}
	
	One of the overarching themes of this study was the difficulty in creating questions that had similar meaning, errors, and syntax in both Clojure and Racket. 
	Often, our questions are somewhat less than idiomatic because of the constraints imposed by the short time commitment we intended for the study.
	For instance, we only use lists in our questions, where idiomatic Clojure prefers vectors, which combine the best features of arrays and lists.
	 Reducing the amount of review and potential sources of confusion was paramount; For instance, Clojure doesn't support tail recursion properly because of the limitations of the Java virtual machine.
	 In order to create tail-recursive structures, idiomatic Clojure uses a construct called loop recur to bypass this limitation.
	 Loop recur has complex syntax and semantics, and so our questions avoid the use of Loop recur, despite the fact that it is idiomatic. 
	 The gap between idiomatic code and testable code is wide, but avoiding complex features is a good start. %\hfcomment{Cond?}

\subsection{Conclusions and future work}\label{sec:future}

\bibliographystyle{eptcs}
\bibliography{usability}
\end{document}



